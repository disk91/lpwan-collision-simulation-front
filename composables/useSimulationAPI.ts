// ~/composables/useSimulationAPI.ts
import { reactive, watch } from 'vue'

// Retrieve the baseURL from a Nuxt context
function getBaseURL() {
  return useRuntimeConfig().public.baseURL;
}

export interface FrameModel {
  channel: number             // Frequency used by the frame
  group: number               // Group to which the frame belongs
  usStart: number             // Start of the frame in microseconds
  usEnd: number               // End of the frame in microseconds
  collision: boolean          // Indicates a local collision (a fragment)
  lost: boolean               // Indicates a global collision (frame loss)
  next?: FrameModel | null    // Link to the next frame
  first: boolean              // Indicates if it is the first frame in the chain
}

export interface SimulationModel {
  simulationRunning: boolean          // Indicates if the simulation is running
  simulationMessagePerSecond: number  // Number of messages per second
  MiotyModelRun: boolean              // Indicates if the MIOTY model is running
  MiotyFrames: FrameModel[]           // Frames generated by the MIOTY model
  SigfoxModelRun: boolean             // Indicates if the Sigfox model is running
  SigfoxFrames: FrameModel[]          // Frames generated by the Sigfox model
  LoRaWanRun: boolean                 // Indicates if the LoRaWAN model is running
  LoRaWanFrames: FrameModel[]         // Frames generated by the LoRaWAN model

  totalCollisions: number             // Total number of collisions
  totalFrames: number                 // Total number of frames
}

const simulationState = reactive({
  simulationIds: [] as number[],                      // List of simulation IDs
  simulations: {} as Record<number, SimulationModel>, // Store the simulation data
  simulationsTitle: {} as Record<number, string>,     // Store the title of each simulation
  error: null as string | null,                       // Store the last error message
  connectionStatus: 'disconnected'                    // Store the connection status
})

async function createSimulation() {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    const parameters = {
      simulationMessagePerSecond: 1,
      MiotyModelRun: false,
      SigfoxModelRun: false,
      LoRaWanRun: false,
    }

    const response = await fetch(`${baseURL}/api/new`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(parameters)
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(
        `Error creating simulation: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    const data = await response.json()
    const simulationId = data.id;
    const title = `simulation ${simulationId}`; // Generate the title with the ID

    simulationState.simulationIds.push(simulationId)
    simulationState.simulationsTitle[simulationId] = title; // Add the simulation title
    return data
  } catch (error: any) {
    console.error("Error in createSimulation:", error)
    simulationState.error = error.message || "Unknown error"
    throw error
  }
}

async function runSimulation(simulationId: number) {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    if (typeof simulationId !== 'number' && typeof simulationId !== 'string') {
      throw new Error('simulationId must be a number or a string')
    }

    // Start the simulation
    const response = await fetch(`${baseURL}/api/run/${simulationId}`, {
      method: 'POST'
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(
        `Error starting simulation: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    const result = await response.json()

    // Polling every 1 second to update the simulation
    const interval = setInterval(async () => {
      console.log("Polling simulation...");
      try {
        const simulationData = await getSimulationValues(simulationId);
        if (!simulationData.simulationRunning) { // Stop polling when the simulation is finished
          clearInterval(interval);
        }
      } catch (error) {
        clearInterval(interval);
        console.error("Error during simulation polling:", error);
      }
    }, 1000);

    return result;
  } catch (error: any) {
    console.error("Error in runSimulation:", error)
    simulationState.error = error.message || "Unknown error"
    throw error
  }
}

async function getSimulationValues(simulationId: number) {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    const response = await fetch(`${baseURL}/api/get_values/${simulationId}`)
    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(
        `Error retrieving results: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    const data = (await response.json()) as SimulationModel
    // Update the simulation in the store for real-time tracking
    simulationState.simulations[simulationId] = data
    //console.log(data)
    return data
  } catch (error: any) {
    console.error("Error in getSimulationValues:", error)
    simulationState.error = error.message || "Unknown error"
    throw error
  }
}

async function getSimulationIds() {
  simulationState.error = null;
  const baseURL = getBaseURL();
  try {
    const response = await fetch(`${baseURL}/api/get_ids`);

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        `Error retrieving IDs: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      );
    }

    const data = await response.json();

    if (!data?.id || !Array.isArray(data.id)) {
      throw new Error(`Unexpected API response: ${JSON.stringify(data)}`);
    }

    simulationState.simulationIds = data.id; // Store only the array of IDs

    // Generate titles for each simulation
    data.id.forEach((simulationId: number) => {
      simulationState.simulationsTitle[simulationId] = `simulation ${simulationId}`;
    });

    return data.id;
  } catch (error: any) {
    console.error("Error in getSimulationIds:", error);
    simulationState.error = error.message || "Unknown error";
    throw error;
  }
}

async function setSimulationParameters(simulationId: number, parameters: any) {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    if (typeof simulationId !== 'number' && typeof simulationId !== 'string') {
      throw new Error('simulationId must be a number or a string')
    }

    const response = await fetch(`${baseURL}/api/set_parameters/${simulationId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(parameters)
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(
        `Error setting parameters: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    return await response.json()
  } catch (error: any) {
    console.error("Error in setSimulationParameters:", error)
    simulationState.error = error.message || "Unknown error"
    throw error
  }
}

async function deleteSimulation(simulationId: number) {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    if (typeof simulationId !== 'number' && typeof simulationId !== 'string') {
      throw new Error('simulationId must be a number or a string')
    }

    const response = await fetch(`${baseURL}/api/delete/${simulationId}`, {
      method: 'POST'
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(
        `Error deleting simulation: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    const result = await response.json()
    simulationState.simulationIds = simulationState.simulationIds.filter(id => id !== simulationId)
    delete simulationState.simulations[simulationId]
    return result
  } catch (error: any) {
    console.error("Error in deleteSimulation:", error)
    simulationState.error = error.message || "Unknown error"
    throw error
  }
}

function waitUntilSimulationFinished(simulationId: number): Promise<SimulationModel> {
  return new Promise((resolve, reject) => {
    const checkInterval = setInterval(() => {
      const simulation = simulationState.simulations[simulationId];
      if (simulation) {
        if (!simulation.simulationRunning) {
          clearInterval(checkInterval);
          resolve(simulation);
        }
      } else {
        clearInterval(checkInterval);
        reject(new Error(`Simulation with ID ${simulationId} not found`));
      }
    }, 100); // Check every 0.1 seconds
  });
}

async function pingServer() {
  simulationState.error = null
  const baseURL = getBaseURL();
  try {
    const response = await fetch(`${baseURL}/api/ping`)

    if (!response.ok) {
      const errorData = await response.json()
      simulationState.connectionStatus = 'disconnected'
      throw new Error(
        `Error pinging server: ${response.status} ${response.statusText} - ${errorData?.message || 'Details not available'}`
      )
    }

    simulationState.connectionStatus = 'connected'
    return await response.json()
  } catch (error: any) {
    console.error("Error in pingServer:", error)
    simulationState.error = error.message || "Unknown error"
    simulationState.connectionStatus = 'disconnected'
    throw error
  }
}

export default {
  simulationState,
  createSimulation,
  runSimulation,
  getSimulationValues,
  getSimulationIds,
  setSimulationParameters,
  deleteSimulation,
  pingServer,
  waitUntilSimulationFinished
}

export function useSimulationAPI() {
  return {
    simulationState,
    createSimulation,
    runSimulation,
    getSimulationValues,
    getSimulationIds,
    setSimulationParameters,
    deleteSimulation,
    pingServer,
    waitUntilSimulationFinished
  }
}
